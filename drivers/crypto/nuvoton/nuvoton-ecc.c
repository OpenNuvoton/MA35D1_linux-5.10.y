// SPDX-License-Identifier: GPL-2.0
/*
 * linux/driver/crypto/nuvoton/nuvoton-ecc.c
 *
 * Copyright (c) 2020 Nuvoton technology corporation.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation;version 2 of the License.
 *
 */
#include <linux/dma-mapping.h>
#include <linux/module.h>
#include <linux/interrupt.h>
#include <linux/kernel.h>
#include <linux/of.h>
#include <linux/tee_drv.h>
#include <linux/crypto.h>
#include <linux/spinlock.h>
#include <linux/scatterlist.h>
#include <crypto/scatterwalk.h>
#include <crypto/internal/kpp.h>
#include <crypto/kpp.h>
#include <crypto/ecdh.h>
#include <linux/io.h>
#include <linux/clk.h>
#include <linux/miscdevice.h>

#include "nuvoton-crypto.h"

static struct nu_ecc_dev  *__ecc_dd;

static struct ecc_curve _Curve[] = {
{
	/* NIST: Curve P-192 : y^2=x^3-ax+b (mod p) */
	CURVE_P_192,
	48,
	"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFE"
	"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC",
	"\x64\x21\x05\x19\xe5\x9c\x80\xe7\x0f\xa7\xe9\xab\x72\x24\x30\x49"
	"\xfe\xb8\xde\xec\xc1\x46\xb9\xb1",
	"\x18\x8d\xa8\x0e\xb0\x30\x90\xf6\x7c\xbf\x20\xeb\x43\xa1\x88\x00"
	"\xf4\xff\x0a\xfd\x82\xff\x10\x12",
	"\x07\x19\x2b\x95\xff\xc8\xda\x78\x63\x10\x11\xed\x6b\x24\xcd\xd5"
	"\x73\xf9\x77\xa1\x1e\x79\x48\x11",
	48,
	"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFE"
	"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
	48,
	"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x99\xDE\xF8\x36"
	"\x14\x6B\xC9\xB1\xB4\xD2\x28\x31",
	192,
	7,
	2,
	1,
	CURVE_GF_P
},
{
	/* NIST: Curve P-224 : y^2=x^3-ax+b (mod p) */
	CURVE_P_224,
	56,
	"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFE"
	"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFE",
	"\xb4\x05\x0a\x85\x0c\x04\xb3\xab\xf5\x41\x32\x56\x50\x44\xb0\xb7"
	"\xd7\xbf\xd8\xba\x27\x0b\x39\x43\x23\x55\xff\xb4",
	"\xb7\x0e\x0c\xbd\x6b\xb4\xbf\x7f\x32\x13\x90\xb9\x4a\x03\xc1\xd3"
	"\x56\xc2\x11\x22\x34\x32\x80\xd6\x11\x5c\x1d\x21",
	"\xbd\x37\x63\x88\xb5\xf7\x23\xfb\x4c\x22\xdf\xe6\xcd\x43\x75\xa0"
	"\x5a\x07\x47\x64\x44\xd5\x81\x99\x85\x00\x7e\x34",
	56,
	"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01",
	56,
	"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\xA2"
	"\xE0\xB8\xF0\x3E\x13\xDD\x29\x45\x5C\x5C\x2A\x3D",
	224,
	9,
	8,
	3,
	CURVE_GF_P
},
{
	/* NIST: Curve P-256 : y^2=x^3-ax+b (mod p) */
	CURVE_P_256,
	64,
	"\xFF\xFF\xFF\xFF\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC",
	"\x5a\xc6\x35\xd8\xaa\x3a\x93\xe7\xb3\xeb\xbd\x55\x76\x98\x86\xbc"
	"\x65\x1d\x06\xb0\xcc\x53\xb0\xf6\x3b\xce\x3c\x3e\x27\xd2\x60\x4b",
	"\x6b\x17\xd1\xf2\xe1\x2c\x42\x47\xf8\xbc\xe6\xe5\x63\xa4\x40\xf2"
	"\x77\x03\x7d\x81\x2d\xeb\x33\xa0\xf4\xa1\x39\x45\xd8\x98\xc2\x96",
	"\x4f\xe3\x42\xe2\xfe\x1a\x7f\x9b\x8e\xe7\xeb\x4a\x7c\x0f\x9e\x16"
	"\x2b\xce\x33\x57\x6b\x31\x5e\xce\xcb\xb6\x40\x68\x37\xbf\x51\xf5",
	64,
	"\xFF\xFF\xFF\xFF\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
	64,
	"\xFF\xFF\xFF\xFF\x00\x00\x00\x00\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
	"\xBC\xE6\xFA\xAD\xA7\x17\x9E\x84\xF3\xB9\xCA\xC2\xFC\x63\x25\x51",
	256,
	10,
	5,
	2,
	CURVE_GF_P
},
{
	/* NIST: Curve P-384 : y^2=x^3-ax+b (mod p) */
	CURVE_P_384,
	96,
	"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
	"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFE"
	"\xFF\xFF\xFF\xFF\x00\x00\x00\x00\x00\x00\x00\x00\xFF\xFF\xFF\xFC",
	"\xb3\x31\x2f\xa7\xe2\x3e\xe7\xe4\x98\x8e\x05\x6b\xe3\xf8\x2d\x19"
	"\x18\x1d\x9c\x6e\xfe\x81\x41\x12\x03\x14\x08\x8f\x50\x13\x87\x5a"
	"\xc6\x56\x39\x8d\x8a\x2e\xd1\x9d\x2a\x85\xc8\xed\xd3\xec\x2a\xef",
	"\xaa\x87\xca\x22\xbe\x8b\x05\x37\x8e\xb1\xc7\x1e\xf3\x20\xad\x74"
	"\x6e\x1d\x3b\x62\x8b\xa7\x9b\x98\x59\xf7\x41\xe0\x82\x54\x2a\x38"
	"\x55\x02\xf2\x5d\xbf\x55\x29\x6c\x3a\x54\x5e\x38\x72\x76\x0a\xb7",
	"\x36\x17\xde\x4a\x96\x26\x2c\x6f\x5d\x9e\x98\xbf\x92\x92\xdc\x29"
	"\xf8\xf4\x1d\xbd\x28\x9a\x14\x7c\xe9\xda\x31\x13\xb5\xf0\xb8\xc0"
	"\x0a\x60\xb1\xce\x1d\x7e\x81\x9d\x7a\x43\x1d\x7c\x90\xea\x0e\x5f",
	96,
	"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
	"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFE"
	"\xFF\xFF\xFF\xFF\x00\x00\x00\x00\x00\x00\x00\x00\xFF\xFF\xFF\xFF",
	96,
	"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
	"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xC7\x63\x4D\x81\xF4\x37\x2D\xDF"
	"\x58\x1A\x0D\xB2\x48\xB0\xA7\x7A\xEC\xEC\x19\x6A\xCC\xC5\x29\x73",
	384,
	12,
	3,
	2,
	CURVE_GF_P
},
{
	/* NIST: Curve P-521 : y^2=x^3-ax+b (mod p)*/
	CURVE_P_521,
	131,
	"\x01\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
	"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
	"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
	"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
	"\xFF\xFC",
	"\x00\x51\x95\x3e\xb9\x61\x8e\x1c\x9a\x1f\x92\x9a\x21\xa0\xb6\x85"
	"\x40\xee\xa2\xda\x72\x5b\x99\xb3\x15\xf3\xb8\xb4\x89\x91\x8e\xf1"
	"\x09\xe1\x56\x19\x39\x51\xec\x7e\x93\x7b\x16\x52\xc0\xbd\x3b\xb1"
	"\xbf\x07\x35\x73\xdf\x88\x3d\x2c\x34\xf1\xef\x45\x1f\xd4\x6b\x50"
	"\x3f\x00",
	"\x00\xc6\x85\x8e\x06\xb7\x04\x04\xe9\xcd\x9e\x3e\xcb\x66\x23\x95"
	"\xb4\x42\x9c\x64\x81\x39\x05\x3f\xb5\x21\xf8\x28\xaf\x60\x6b\x4d"
	"\x3d\xba\xa1\x4b\x5e\x77\xef\xe7\x59\x28\xfe\x1d\xc1\x27\xa2\xff"
	"\xa8\xde\x33\x48\xb3\xc1\x85\x6a\x42\x9b\xf9\x7e\x7e\x31\xc2\xe5"
	"\xbd\x66",
	"\x01\x18\x39\x29\x6a\x78\x9a\x3b\xc0\x04\x5c\x8a\x5f\xb4\x2c\x7d"
	"\x1b\xd9\x98\xf5\x44\x49\x57\x9b\x44\x68\x17\xaf\xbd\x17\x27\x3e"
	"\x66\x2c\x97\xee\x72\x99\x5e\xf4\x26\x40\xc5\x50\xb9\x01\x3f\xad"
	"\x07\x61\x35\x3c\x70\x86\xa2\x72\xc2\x40\x88\xbe\x94\x76\x9f\xd1"
	"\x66\x50",
	131,
	"\x01\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
	"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
	"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
	"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
	"\xFF\xFF",
	131,
	"\x01\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
	"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
	"\xFF\xFA\x51\x86\x87\x83\xBF\x2F\x96\x6B\x7F\xCC\x01\x48\xF7\x09"
	"\xA5\xD0\x3B\xB5\xC9\xB8\x89\x9C\x47\xAE\xBB\x6F\xB7\x1E\x91\x38"
	"\x64\x09",
	521,
	32,
	32,
	32,
	CURVE_GF_P
},
{
	/* NIST: Curve B-163 : y^2+xy=x^3+ax^2+b */
	CURVE_B_163,
	41,
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x01",
	"\x02\x0a\x60\x19\x07\xb8\xc9\x53\xca\x14\x81\xeb\x10\x51\x2f\x78"
	"\x74\x4a\x32\x05\xfd",
	"\x03\xf0\xeb\xa1\x62\x86\xa2\xd5\x7e\xa0\x99\x11\x68\xd4\x99\x46"
	"\x37\xe8\x34\x3e\x36",
	"\x00\xd5\x1f\xbc\x6c\x71\xa0\x09\x4f\xa2\xcd\xd5\x45\xb1\x1c\x5c"
	"\x0c\x79\x73\x24\xf1",
	56,
	"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01",
	42,
	"\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x92\xFE\x77\xE7\x0C"
	"\x12\xA4\x23\x4C\x33",
	163,
	7,
	6,
	3,
	CURVE_GF_2M
},
{
	/* NIST: Curve B-233 : y^2+xy=x^3+ax^2+b */
	CURVE_B_233,
	59,
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01",
	"\x00\x66\x64\x7e\xde\x6c\x33\x2c\x7f\x8c\x09\x23\xbb\x58\x21\x3b"
	"\x33\x3b\x20\xe9\xce\x42\x81\xfe\x11\x5f\x7d\x8f\x90\xad",
	"\x00\xfa\xc9\xdf\xcb\xac\x83\x13\xbb\x21\x39\xf1\xbb\x75\x5f\xef"
	"\x65\xbc\x39\x1f\x8b\x36\xf8\xf8\xeb\x73\x71\xfd\x55\x8b",
	"\x01\x00\x6a\x08\xa4\x19\x03\x35\x06\x78\xe5\x85\x28\xbe\xbf\x8a"
	"\x0b\xef\xf8\x67\xa7\xca\x36\x71\x6f\x7e\x01\xf8\x10\x52",
	56,
	"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01",
	60,
	"\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x13"
	"\xE9\x74\xE7\x2F\x8A\x69\x22\x03\x1D\x26\x03\xCF\xE0\xD7",
	233,
	74,
	74,
	74,
	CURVE_GF_2M
},
{
	/* NIST: Curve B-283 : y^2+xy=x^3+ax^2+b */
	CURVE_B_283,
	71,
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x01",
	"\x02\x7b\x68\x0a\xc8\xb8\x59\x6d\xa5\xa4\xaf\x8a\x19\xa0\x30\x3f"
	"\xca\x97\xfd\x76\x45\x30\x9f\xa2\xa5\x81\x48\x5a\xf6\x26\x3e\x31"
	"\x3b\x79\xa2\xf5",
	"\x05\xf9\x39\x25\x8d\xb7\xdd\x90\xe1\x93\x4f\x8c\x70\xb0\xdf\xec"
	"\x2e\xed\x25\xb8\x55\x7e\xac\x9c\x80\xe2\xe1\x98\xf8\xcd\xbe\xcd"
	"\x86\xb1\x20\x53",
	"\x03\x67\x68\x54\xfe\x24\x14\x1c\xb9\x8f\xe6\xd4\xb2\x0d\x02\xb4"
	"\x51\x6f\xf7\x02\x35\x0e\xdd\xb0\x82\x67\x79\xc8\x13\xf0\xdf\x45"
	"\xbe\x81\x12\xf4",
	56,
	"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01",
	72,
	"\x03\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
	"\xFF\xFF\xEF\x90\x39\x96\x60\xFC\x93\x8A\x90\x16\x5B\x04\x2A\x7C"
	"\xEF\xAD\xB3\x07",
	283,
	12,
	7,
	5,
	CURVE_GF_2M
},
{
	/* NIST: Curve B-409 : y^2+xy=x^3+ax^2+b */
	CURVE_B_409,
	103,
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x01",
	"\x00\x21\xa5\xc2\xc8\xee\x9f\xeb\x5c\x4b\x9a\x75\x3b\x7b\x47\x6b"
	"\x7f\xd6\x42\x2e\xf1\xf3\xdd\x67\x47\x61\xfa\x99\xd6\xac\x27\xc8"
	"\xa9\xa1\x97\xb2\x72\x82\x2f\x6c\xd5\x7a\x55\xaa\x4f\x50\xae\x31"
	"\x7b\x13\x54\x5f",
	"\x01\x5d\x48\x60\xd0\x88\xdd\xb3\x49\x6b\x0c\x60\x64\x75\x62\x60"
	"\x44\x1c\xde\x4a\xf1\x77\x1d\x4d\xb0\x1f\xfe\x5b\x34\xe5\x97\x03"
	"\xdc\x25\x5a\x86\x8a\x11\x80\x51\x56\x03\xae\xab\x60\x79\x4e\x54"
	"\xbb\x79\x96\xa7",
	"\x00\x61\xb1\xcf\xab\x6b\xe5\xf3\x2b\xbf\xa7\x83\x24\xed\x10\x6a"
	"\x76\x36\xb9\xc5\xa7\xbd\x19\x8d\x01\x58\xaa\x4f\x54\x88\xd0\x8f"
	"\x38\x51\x4f\x1f\xdf\x4b\x4f\x40\xd2\x18\x1b\x36\x81\xc3\x64\xba"
	"\x02\x73\xc7\x06",
	56,
	"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01",
	104,
	"\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\xE2\xAA\xD6\xA6\x12"
	"\xF3\x33\x07\xBE\x5F\xA4\x7C\x3C\x9E\x05\x2F\x83\x81\x64\xCD\x37"
	"\xD9\xA2\x11\x73",
	409,
	87,
	87,
	87,
	CURVE_GF_2M
},
{
	/* NIST: Curve B-571 : y^2+xy=x^3+ax^2+b */
	CURVE_B_571,
	143,
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x01",
	"\x02\xf4\x0e\x7e\x22\x21\xf2\x95\xde\x29\x71\x17\xb7\xf3\xd6\x2f"
	"\x5c\x6a\x97\xff\xcb\x8c\xef\xf1\xcd\x6b\xa8\xce\x4a\x9a\x18\xad"
	"\x84\xff\xab\xbd\x8e\xfa\x59\x33\x2b\xe7\xad\x67\x56\xa6\x6e\x29"
	"\x4a\xfd\x18\x5a\x78\xff\x12\xaa\x52\x0e\x4d\xe7\x39\xba\xca\x0c"
	"\x7f\xfe\xff\x7f\x29\x55\x72\x7a",
	"\x03\x03\x00\x1d\x34\xb8\x56\x29\x6c\x16\xc0\xd4\x0d\x3c\xd7\x75"
	"\x0a\x93\xd1\xd2\x95\x5f\xa8\x0a\xa5\xf4\x0f\xc8\xdb\x7b\x2a\xbd"
	"\xbd\xe5\x39\x50\xf4\xc0\xd2\x93\xcd\xd7\x11\xa3\x5b\x67\xfb\x14"
	"\x99\xae\x60\x03\x86\x14\xf1\x39\x4a\xbf\xa3\xb4\xc8\x50\xd9\x27"
	"\xe1\xe7\x76\x9c\x8e\xec\x2d\x19",
	"\x03\x7b\xf2\x73\x42\xda\x63\x9b\x6d\xcc\xff\xfe\xb7\x3d\x69\xd7"
	"\x8c\x6c\x27\xa6\x00\x9c\xbb\xca\x19\x80\xf8\x53\x39\x21\xe8\xa6"
	"\x84\x42\x3e\x43\xba\xb0\x8a\x57\x62\x91\xaf\x8f\x46\x1b\xb2\xa8"
	"\xb3\x53\x1d\x2f\x04\x85\xc1\x9b\x16\xe2\xf1\x51\x6e\x23\xdd\x3c"
	"\x1a\x48\x27\xaf\x1b\x8a\xc1\x5b",
	56,
	"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01",
	144,
	"\x03\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
	"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
	"\xFF\xFF\xFF\xFF\xE6\x61\xCE\x18\xFF\x55\x98\x73\x08\x05\x9B\x18"
	"\x68\x23\x85\x1E\xC7\xDD\x9C\xA1\x16\x1D\xE9\x3D\x51\x74\xD6\x6E"
	"\x83\x82\xE9\xBB\x2F\xE8\x4E\x47",
	571,
	10,
	5,
	2,
	CURVE_GF_2M
},
{
	/* NIST: Curve K-163 : y^2+xy=x^3+ax^2+b */
	CURVE_K_163,
	41,
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x01",
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x01",
	"\x02\xfe\x13\xc0\x53\x7b\xbc\x11\xac\xaa\x07\xd7\x93\xde\x4e\x6d"
	"\x5e\x5c\x94\xee\xe8",
	"\x02\x89\x07\x0f\xb0\x5d\x38\xff\x58\x32\x1f\x2e\x80\x05\x36\xd5"
	"\x38\xcc\xda\xa3\xd9",
	56,
	"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01",
	41,
	"\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x01\x08\xA2\xE0\xCC"
	"\x0D\x99\xF8\xA5\xEF",
	163,
	7,
	6,
	3,
	CURVE_GF_2M
},
{
	/* NIST: Curve K-233 : y^2+xy=x^3+ax^2+b */
	CURVE_K_233,
	59,
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01",
	"\x01\x72\x32\xba\x85\x3a\x7e\x73\x1a\xf1\x29\xf2\x2f\xf4\x14\x95"
	"\x63\xa4\x19\xc2\x6b\xf5\x0a\x4c\x9d\x6e\xef\xad\x61\x26",
	"\x01\xdb\x53\x7d\xec\xe8\x19\xb7\xf7\x0f\x55\x5a\x67\xc4\x27\xa8"
	"\xcd\x9b\xf1\x8a\xeb\x9b\x56\xe0\xc1\x10\x56\xfa\xe6\xa3",
	56,
	"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01",
	58,
	"\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x06\x9D"
	"\x5B\xB9\x15\xBC\xD4\x6E\xFB\x1A\xD5\xF1\x73\xAB\xDF",
	233,
	74,
	74,
	74,
	CURVE_GF_2M
},
{
	/* NIST: Curve K-283 : y^2+xy=x^3+ax^2+b */
	CURVE_K_283,
	71,     /* Echar */
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00",
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x01",
	"\x05\x03\x21\x3f\x78\xca\x44\x88\x3f\x1a\x3b\x81\x62\xf1\x88\xe5"
	"\x53\xcd\x26\x5f\x23\xc1\x56\x7a\x16\x87\x69\x13\xb0\xc2\xac\x24"
	"\x58\x49\x28\x36",
	"\x01\xcc\xda\x38\x0f\x1c\x9e\x31\x8d\x90\xf9\x5d\x07\xe5\x42\x6f"
	"\xe8\x7e\x45\xc0\xe8\x18\x46\x98\xe4\x59\x62\x36\x4e\x34\x11\x61"
	"\x77\xdd\x22\x59",
	56,
	"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01",
	71,
	"\x01\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
	"\xFF\xFF\xE9\xAE\x2E\xD0\x75\x77\x26\x5D\xFF\x7F\x94\x45\x1E\x06"
	"\x1E\x16\x3C\x61",
	283,
	12,
	7,
	5,
	CURVE_GF_2M
},
{
	/* NIST: Curve K-409 : y^2+xy=x^3+ax^2+b */
	CURVE_K_409,
	103,     /* Echar */
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00",
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x01",
	"\x00\x60\xf0\x5f\x65\x8f\x49\xc1\xad\x3a\xb1\x89\x0f\x71\x84\x21"
	"\x0e\xfd\x09\x87\xe3\x07\xc8\x4c\x27\xac\xcf\xb8\xf9\xf6\x7c\xc2"
	"\xc4\x60\x18\x9e\xb5\xaa\xaa\x62\xee\x22\x2e\xb1\xb3\x55\x40\xcf"
	"\xe9\x02\x37\x46",
	"\x01\xe3\x69\x05\x0b\x7c\x4e\x42\xac\xba\x1d\xac\xbf\x04\x29\x9c"
	"\x34\x60\x78\x2f\x91\x8e\xa4\x27\xe6\x32\x51\x65\xe9\xea\x10\xe3"
	"\xda\x5f\x6c\x42\xe9\xc5\x52\x15\xaa\x9c\xa2\x7a\x58\x63\xec\x48"
	"\xd8\xe0\x28\x6b",
	56,
	"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01",
	102,
	"\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
	"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFE\x5F\x83\xB2\xD4\xEA\x20"
	"\x40\x0E\xC4\x55\x7D\x5E\xD3\xE3\xE7\xCA\x5B\x4B\x5C\x83\xB8\xE0"
	"\x1E\x5F\xCF",
	409,
	87,
	87,
	87,
	CURVE_GF_2M
},
{
	/* NIST: Curve K-571 : y^2+xy=x^3+ax^2+b */
	CURVE_K_571,
	143,
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00",
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x01",
	"\x02\x6e\xb7\xa8\x59\x92\x3f\xbc\x82\x18\x96\x31\xf8\x10\x3f\xe4"
	"\xac\x9c\xa2\x97\x00\x12\xd5\xd4\x60\x24\x80\x48\x01\x84\x1c\xa4"
	"\x43\x70\x95\x84\x93\xb2\x05\xe6\x47\xda\x30\x4d\xb4\xce\xb0\x8c"
	"\xbb\xd1\xba\x39\x49\x47\x76\xfb\x98\x8b\x47\x17\x4d\xca\x88\xc7"
	"\xe2\x94\x52\x83\xa0\x1c\x89\x72",
	"\x03\x49\xdc\x80\x7f\x4f\xbf\x37\x4f\x4a\xea\xde\x3b\xca\x95\x31"
	"\x4d\xd5\x8c\xec\x9f\x30\x7a\x54\xff\xc6\x1e\xfc\x00\x6d\x8a\x2c"
	"\x9d\x49\x79\xc0\xac\x44\xae\xa7\x4f\xbe\xbb\xb9\xf7\x72\xae\xdc"
	"\xb6\x20\xb0\x1a\x7b\xa7\xaf\x1b\x32\x04\x30\xc8\x59\x19\x84\xf6"
	"\x01\xcd\x4c\x14\x3e\xf1\xc7\xa3",
	56,
	"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01",
	143,
	"\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x13\x18\x50\xE1\xF1\x9A\x63\xE4\xB3\x91\xA8\xDB"
	"\x91\x7F\x41\x38\xB6\x30\xD8\x4B\xE5\xD6\x39\x38\x1E\x91\xDE\xB4"
	"\x5C\xFE\x77\x8F\x63\x7C\x10\x01",
	571,
	10,
	5,
	2,
	CURVE_GF_2M
},
{
	/* Koblitz: Curve secp192k1 : y2 = x3+ax+b over Fp */
	CURVE_KO_192,
	48,
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00",
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x03",
	"\xDB\x4F\xF1\x0E\xC0\x57\xE9\xAE\x26\xB0\x7D\x02\x80\xB7\xF4\x34"
	"\x1D\xA5\xD1\xB1\xEA\xE0\x6C\x7D",
	"\x9B\x2F\x2F\x6D\x9C\x56\x28\xA7\x84\x41\x63\xD0\x15\xBE\x86\x34"
	"\x40\x82\xAA\x88\xD9\x5E\x2F\x9D",
	48,
	"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
	"\xFF\xFF\xFF\xFE\xFF\xFF\xEE\x37",
	48,
	"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFE\x26\xF2\xFC\x17"
	"\x0F\x69\x46\x6A\x74\xDE\xFD\x8D",
	192,
	7,
	2,
	1,
	CURVE_GF_P
},
{
	/* Koblitz: Curve secp224k1 : y2 = x3+ax+b over Fp */
	CURVE_KO_224,
	56,
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x05",
	"\xA1\x45\x5B\x33\x4D\xF0\x99\xDF\x30\xFC\x28\xA1\x69\xA4\x67\xE9"
	"\xE4\x70\x75\xA9\x0F\x7E\x65\x0E\xB6\xB7\xA4\x5C",
	"\x7E\x08\x9F\xED\x7F\xBA\x34\x42\x82\xCA\xFB\xD6\xF7\xE3\x19\xF7"
	"\xC0\xB0\xBD\x59\xE2\xCA\x4B\xDB\x55\x6D\x61\xA5",
	56,
	"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
	"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFE\xFF\xFF\xE5\x6D",
	56,
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\xDC\xE8"
	"\xD2\xEC\x61\x84\xCA\xF0\xA9\x71\x76\x9F\xB1\xF7",
	224,
	7,
	2,
	1,
	CURVE_GF_P
},
{
	/* Koblitz: Curve secp256k1 : y2 = x3+ax+b over Fp */
	CURVE_KO_256,
	64,
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x07",
	"\x79\xBE\x66\x7E\xF9\xDC\xBB\xAC\x55\xA0\x62\x95\xCE\x87\x0B\x07"
	"\x02\x9B\xFC\xDB\x2D\xCE\x28\xD9\x59\xF2\x81\x5B\x16\xF8\x17\x98",
	"\x48\x3A\xDA\x77\x26\xA3\xC4\x65\x5D\xA4\xFB\xFC\x0E\x11\x08\xA8"
	"\xFD\x17\xB4\x48\xA6\x85\x54\x19\x9C\x47\xD0\x8F\xFB\x10\xD4\xB8",
	64,
	"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
	"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFE\xFF\xFF\xFC\x2F",
	64,
	"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFE"
	"\xBA\xAE\xDC\xE6\xAF\x48\xA0\x3B\xBF\xD2\x5E\x8C\xD0\x36\x41\x41",
	256,
	7,
	2,
	1,
	CURVE_GF_P
},
{
	/* Brainpool: Curve brainpoolP256r1 */
	CURVE_BP_256,
	64,
	"\x7D\x5A\x09\x75\xFC\x2C\x30\x57\xEE\xF6\x75\x30\x41\x7A\xFF\xE7"
	"\xFB\x80\x55\xC1\x26\xDC\x5C\x6C\xE9\x4A\x4B\x44\xF3\x30\xB5\xD9",
	"\x26\xDC\x5C\x6C\xE9\x4A\x4B\x44\xF3\x30\xB5\xD9\xBB\xD7\x7C\xBF"
	"\x95\x84\x16\x29\x5C\xF7\xE1\xCE\x6B\xCC\xDC\x18\xFF\x8C\x07\xB6",
	"\x8B\xD2\xAE\xB9\xCB\x7E\x57\xCB\x2C\x4B\x48\x2F\xFC\x81\xB7\xAF"
	"\xB9\xDE\x27\xE1\xE3\xBD\x23\xC2\x3A\x44\x53\xBD\x9A\xCE\x32\x62",
	"\x54\x7E\xF8\x35\xC3\xDA\xC4\xFD\x97\xF8\x46\x1A\x14\x61\x1D\xC9"
	"\xC2\x77\x45\x13\x2D\xED\x8E\x54\x5C\x1D\x54\xC7\x2F\x04\x69\x97",
	64,
	"\xA9\xFB\x57\xDB\xA1\xEE\xA9\xBC\x3E\x66\x0A\x90\x9D\x83\x8D\x72"
	"\x6E\x3B\xF6\x23\xD5\x26\x20\x28\x20\x13\x48\x1D\x1F\x6E\x53\x77",
	64,
	"\xA9\xFB\x57\xDB\xA1\xEE\xA9\xBC\x3E\x66\x0A\x90\x9D\x83\x8D\x71"
	"\x8C\x39\x7A\xA3\xB5\x61\xA6\xF7\x90\x1E\x0E\x82\x97\x48\x56\xA7",
	256,
	7,
	2,
	1,
	CURVE_GF_P
},
{
	/* Brainpool: Curve brainpoolP384r1 */
	CURVE_BP_384,
	96,
	"\x7B\xC3\x82\xC6\x3D\x8C\x15\x0C\x3C\x72\x08\x0A\xCE\x05\xAF\xA0"
	"\xC2\xBE\xA2\x8E\x4F\xB2\x27\x87\x13\x91\x65\xEF\xBA\x91\xF9\x0F"
	"\x8A\xA5\x81\x4A\x50\x3A\xD4\xEB\x04\xA8\xC7\xDD\x22\xCE\x28\x26",
	"\x04\xA8\xC7\xDD\x22\xCE\x28\x26\x8B\x39\xB5\x54\x16\xF0\x44\x7C"
	"\x2F\xB7\x7D\xE1\x07\xDC\xD2\xA6\x2E\x88\x0E\xA5\x3E\xEB\x62\xD5"
	"\x7C\xB4\x39\x02\x95\xDB\xC9\x94\x3A\xB7\x86\x96\xFA\x50\x4C\x11",
	"\x1D\x1C\x64\xF0\x68\xCF\x45\xFF\xA2\xA6\x3A\x81\xB7\xC1\x3F\x6B"
	"\x88\x47\xA3\xE7\x7E\xF1\x4F\xE3\xDB\x7F\xCA\xFE\x0C\xBD\x10\xE8"
	"\xE8\x26\xE0\x34\x36\xD6\x46\xAA\xEF\x87\xB2\xE2\x47\xD4\xAF\x1E",
	"\x8A\xBE\x1D\x75\x20\xF9\xC2\xA4\x5C\xB1\xEB\x8E\x95\xCF\xD5\x52"
	"\x62\xB7\x0B\x29\xFE\xEC\x58\x64\xE1\x9C\x05\x4F\xF9\x91\x29\x28"
	"\x0E\x46\x46\x21\x77\x91\x81\x11\x42\x82\x03\x41\x26\x3C\x53\x15",
	96,
	"\x8C\xB9\x1E\x82\xA3\x38\x6D\x28\x0F\x5D\x6F\x7E\x50\xE6\x41\xDF"
	"\x15\x2F\x71\x09\xED\x54\x56\xB4\x12\xB1\xDA\x19\x7F\xB7\x11\x23"
	"\xAC\xD3\xA7\x29\x90\x1D\x1A\x71\x87\x47\x00\x13\x31\x07\xEC\x53",
	96,
	"\x8C\xB9\x1E\x82\xA3\x38\x6D\x28\x0F\x5D\x6F\x7E\x50\xE6\x41\xDF"
	"\x15\x2F\x71\x09\xED\x54\x56\xB3\x1F\x16\x6E\x6C\xAC\x04\x25\xA7"
	"\xCF\x3A\xB6\xAF\x6B\x7F\xC3\x10\x3B\x88\x32\x02\xE9\x04\x65\x65",
	384,
	7,
	2,
	1,
	CURVE_GF_P
},
{
	/* Brainpool: Curve brainpoolP512r1 */
	CURVE_BP_512,
	128,
	"\x78\x30\xA3\x31\x8B\x60\x3B\x89\xE2\x32\x71\x45\xAC\x23\x4C\xC5"
	"\x94\xCB\xDD\x8D\x3D\xF9\x16\x10\xA8\x34\x41\xCA\xEA\x98\x63\xBC"
	"\x2D\xED\x5D\x5A\xA8\x25\x3A\xA1\x0A\x2E\xF1\xC9\x8B\x9A\xC8\xB5"
	"\x7F\x11\x17\xA7\x2B\xF2\xC7\xB9\xE7\xC1\xAC\x4D\x77\xFC\x94\xCA",
	"\x3D\xF9\x16\x10\xA8\x34\x41\xCA\xEA\x98\x63\xBC\x2D\xED\x5D\x5A"
	"\xA8\x25\x3A\xA1\x0A\x2E\xF1\xC9\x8B\x9A\xC8\xB5\x7F\x11\x17\xA7"
	"\x2B\xF2\xC7\xB9\xE7\xC1\xAC\x4D\x77\xFC\x94\xCA\xDC\x08\x3E\x67"
	"\x98\x40\x50\xB7\x5E\xBA\xE5\xDD\x28\x09\xBD\x63\x80\x16\xF7\x23",
	"\x81\xAE\xE4\xBD\xD8\x2E\xD9\x64\x5A\x21\x32\x2E\x9C\x4C\x6A\x93"
	"\x85\xED\x9F\x70\xB5\xD9\x16\xC1\xB4\x3B\x62\xEE\xF4\xD0\x09\x8E"
	"\xFF\x3B\x1F\x78\xE2\xD0\xD4\x8D\x50\xD1\x68\x7B\x93\xB9\x7D\x5F"
	"\x7C\x6D\x50\x47\x40\x6A\x5E\x68\x8B\x35\x22\x09\xBC\xB9\xF8\x22",
	"\x7D\xDE\x38\x5D\x56\x63\x32\xEC\xC0\xEA\xBF\xA9\xCF\x78\x22\xFD"
	"\xF2\x09\xF7\x00\x24\xA5\x7B\x1A\xA0\x00\xC5\x5B\x88\x1F\x81\x11"
	"\xB2\xDC\xDE\x49\x4A\x5F\x48\x5E\x5B\xCA\x4B\xD8\x8A\x27\x63\xAE"
	"\xD1\xCA\x2B\x2F\xA8\xF0\x54\x06\x78\xCD\x1E\x0F\x3A\xD8\x08\x92",
	128,
	"\xAA\xDD\x9D\xB8\xDB\xE9\xC4\x8B\x3F\xD4\xE6\xAE\x33\xC9\xFC\x07"
	"\xCB\x30\x8D\xB3\xB3\xC9\xD2\x0E\xD6\x63\x9C\xCA\x70\x33\x08\x71"
	"\x7D\x4D\x9B\x00\x9B\xC6\x68\x42\xAE\xCD\xA1\x2A\xE6\xA3\x80\xE6"
	"\x28\x81\xFF\x2F\x2D\x82\xC6\x85\x28\xAA\x60\x56\x58\x3A\x48\xF3",
	128,
	"\xAA\xDD\x9D\xB8\xDB\xE9\xC4\x8B\x3F\xD4\xE6\xAE\x33\xC9\xFC\x07"
	"\xCB\x30\x8D\xB3\xB3\xC9\xD2\x0E\xD6\x63\x9C\xCA\x70\x33\x08\x70"
	"\x55\x3E\x5C\x41\x4C\xA9\x26\x19\x41\x86\x61\x19\x7F\xAC\x10\x47"
	"\x1D\xB1\xD3\x81\x08\x5D\xDA\xDD\xB5\x87\x96\x82\x9C\xA9\x00\x69",
	512,
	7,
	2,
	1,
	CURVE_GF_P
},
{
	/* NIST: Curve P-256 : y^2=x^3-ax+b (mod p) */
	CURVE_SM2_256,
	64,
	"\xFF\xFF\xFF\xFE\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
	"\xFF\xFF\xFF\xFF\x00\x00\x00\x00\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC",
	"\x28\xE9\xFA\x9E\x9D\x9F\x5E\x34\x4D\x5A\x9E\x4B\xCF\x65\x09\xA7"
	"\xF3\x97\x89\xF5\x15\xAB\x8F\x92\xDD\xBC\xBD\x41\x4D\x94\x0E\x93",
	"\x32\xC4\xAE\x2C\x1F\x19\x81\x19\x5F\x99\x04\x46\x6A\x39\xC9\x94"
	"\x8F\xE3\x0B\xBF\xF2\x66\x0B\xE1\x71\x5A\x45\x89\x33\x4C\x74\xC7",
	"\xBC\x37\x36\xA2\xF4\xF6\x77\x9C\x59\xBD\xCE\xE3\x6B\x69\x21\x53"
	"\xD0\xA9\x87\x7C\xC6\x2A\x47\x40\x02\xDF\x32\xE5\x21\x39\xF0\xA0",
	64,
	"\xFF\xFF\xFF\xFE\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
	"\xFF\xFF\xFF\xFF\x00\x00\x00\x00\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
	64,
	"\xFF\xFF\xFF\xFE\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
	"\x72\x03\xDF\x6B\x21\xC6\x05\x2B\x53\xBB\xF4\x09\x39\xD5\x41\x23",
	256,
	10,
	5,
	2,
	CURVE_GF_P
},
{
	CURVE_25519,
	64,
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x07\x6D\x06",
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01",
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x09",
	"\x20\xae\x19\xa1\xb8\xa0\x86\xb4\xe0\x1e\xdd\x2c\x77\x48\xd1\x4c"
	"\x92\x3d\x4d\x7e\x6d\x7c\x61\xb2\x29\xe9\xc5\xa2\x7e\xce\xd3\xd9",
	64,
	"\x7f\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
	"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xed",
	64,
	"\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x14\xde\xf9\xde\xa2\xf7\x9c\xd6\x58\x12\x63\x1a\x5c\xf5\xd3\xed",
	255,
	10,
	5,
	2,
	CURVE_GF_P
},
};

static int  optee_ecc_open(struct nu_ecc_dev *dd);

struct ecc_curve *get_curve(int ecc_curve)
{
	int   i;

	for (i = 0UL; i < sizeof(_Curve) / sizeof(struct ecc_curve); i++) {
		if (ecc_curve == _Curve[i].curve_id)
			return &_Curve[i];
	}
	return NULL;
}


struct nu_ecc_drv {
	struct list_head dev_list;
	/* Device list lock */
	spinlock_t lock;
};

static struct nu_ecc_drv nu_ecc = {
	.dev_list = LIST_HEAD_INIT(nu_ecc.dev_list),
	.lock = __SPIN_LOCK_UNLOCKED(nu_ecc.lock),
};

static struct nu_ecc_dev *nuvoton_ecc_find_dev(struct nu_ecc_ctx *tctx)
{
	struct nu_ecc_dev *dd = NULL;
	struct nu_ecc_dev *tmp;

	spin_lock_bh(&nu_ecc.lock);
	if (!tctx->dd) {
		list_for_each_entry(tmp, &nu_ecc.dev_list, list) {
			dd = tmp;
			break;
		}
		tctx->dd = dd;
	} else {
		dd = tctx->dd;
	}
	spin_unlock_bh(&nu_ecc.lock);
	return dd;
}

static inline void nu_write_reg(struct nu_ecc_dev *ecc_dd, u32 val, u32 reg)
{
	if (ecc_dd->nu_cdev->use_optee == true)
		ecc_dd->va_shm[reg / 4] = val;
	else
		writel_relaxed(val, ecc_dd->reg_base + reg);
}

static inline u32 nu_read_reg(struct nu_ecc_dev *ecc_dd, u32 reg)
{
	if (ecc_dd->nu_cdev->use_optee == true)
		return ecc_dd->va_shm[reg / 4];
	else
		return readl_relaxed(ecc_dd->reg_base + reg);
}

static inline void nu_write_ecc_key(struct nu_ecc_ctx *ctx, u8 *key, u32 reg)
{
	struct nu_ecc_dev *dd = ctx->dd;
	u32	val32;
	int	i, ri;

	i = ctx->keylen - 1;
	for (ri = 0; (ri < 18) && (i >= 0); ri++) {
		val32 = 0;
		if ((i - 3) >= 0)
			val32 |= (key[i-3] << 24);
		if ((i - 2) >= 0)
			val32 |= (key[i-2] << 16);
		if ((i - 1) >= 0)
			val32 |= (key[i-1] << 8);
		val32 |= key[i];
		i -= 4;
		nu_write_reg(dd, val32, reg + ri * 4);
	}
}

static inline void nu_read_ecc_key(struct nu_ecc_ctx *ctx, u32 reg, u8 *key)
{
	struct nu_ecc_dev *dd = ctx->dd;
	u32	val32;
	int	i, idx;

	idx = ((ctx->keylen + 3) / 4) - 1;
	for (i = 0; i < ctx->keylen; i += 4) {
		val32 = nu_read_reg(dd, reg + idx * 4);
		idx--;
		key[i]   = (val32 >> 24) & 0xff;
		key[i+1] = (val32 >> 16) & 0xff;
		key[i+2] = (val32 >> 8) & 0xff;
		key[i+3] = val32 & 0xff;
	}
}

static const char hex_char_tbl[] = "0123456789abcdef";

static void ecc_key_to_str(u8 *key, char *kstr, int keylen)
{
	int   i;

	for (i = 0; i < keylen; i++) {
		*kstr++ = hex_char_tbl[(*key >> 4) & 0xf];
		*kstr++ = hex_char_tbl[*key & 0xf];
		key++;
	}
	*kstr++ = 0;
	*kstr = 0;
}

static inline int get_nibble_value(char c)
{
	if ((c >= '0') && (c <= '9'))
		c = c - '0';

	if ((c >= 'a') && (c <= 'f'))
		c = c - 'a' + (char)10;

	if ((c >= 'A') && (c <= 'F'))
		c = c - 'A' + (char)10;

	return (int)c;
}

static inline int nuvoton_wait_ecc_complete(struct nu_ecc_dev *dd, int timeout)
{
	unsigned long   t_out;

	t_out = jiffies + timeout;
	while (nu_read_reg(dd, ECC_STS) & (ECC_STS_BUSY | ECC_STS_DMABUSY)) {
		if (!time_before(jiffies, t_out)) {
			nu_write_reg(dd, ECC_CTL_STOP, ECC_CTL);
			pr_err("ECC hardware timeout! 0x%x\n",
				nu_read_reg(dd, ECC_STS));
			return -EBUSY;
		}

		if (nu_read_reg(dd, ECC_STS) &
			(ECC_STS_BUSERR | ECC_STS_KSERR)) {
			pr_err("ECC hardware error! 0x%x\n",
				nu_read_reg(dd, ECC_STS));
			return -EIO;
		}
	}
	return 0;
}

static int nuvoton_ecc_init_curve(int curve_id, struct nu_ecc_ctx *ctx)
{
	struct nu_ecc_dev *dd = ctx->dd;
	struct ecc_curve  *curve = NULL;
	u32	reg;
	int	i;

	curve = get_curve(curve_id);
	if (curve == NULL) {
		pr_err("%s - invalid curve_id %d!\n", __func__, curve_id);
		return -EINVAL;
	}
	ctx->curve_id = curve_id;
	ctx->curve = curve;
	ctx->keylen = (curve->key_len + 7) / 8;

	for (i = 0; i < 18; i++) {
		nu_write_reg(dd, 0, ECC_X1 + i * 4);
		nu_write_reg(dd, 0, ECC_Y1 + i * 4);
		nu_write_reg(dd, 0, ECC_X2 + i * 4);
		nu_write_reg(dd, 0, ECC_Y2 + i * 4);
		nu_write_reg(dd, 0, ECC_A + i * 4);
		nu_write_reg(dd, 0, ECC_B + i * 4);
		nu_write_reg(dd, 0, ECC_N + i * 4);
		nu_write_reg(dd, 0, ECC_K + i * 4);
	}

	nu_write_ecc_key(ctx, curve->Px, ECC_X1);
	nu_write_ecc_key(ctx, curve->Py, ECC_Y1);
	nu_write_ecc_key(ctx, curve->Ea, ECC_A);
	nu_write_ecc_key(ctx, curve->Eb, ECC_B);

	if (curve->GF == CURVE_GF_2M) {
		nu_write_reg(dd, 0x1, ECC_N);
		reg = ECC_N + (curve->key_len / 32) * 4;
		nu_write_reg(dd, nu_read_reg(dd, reg) |
				(0x1 << (curve->key_len % 32)), reg);
		reg = ECC_N + (curve->irreducible_k1 / 32) * 4;
		nu_write_reg(dd, nu_read_reg(dd, reg) |
				(0x1 << (curve->irreducible_k1 % 32)), reg);
		reg = ECC_N + (curve->irreducible_k2 / 32) * 4;
		nu_write_reg(dd, nu_read_reg(dd, reg) |
				(0x1 << (curve->irreducible_k2 % 32)), reg);
		reg = ECC_N + (curve->irreducible_k3 / 32) * 4;
		nu_write_reg(dd, nu_read_reg(dd, reg) |
				(0x1 << (curve->irreducible_k3 % 32)), reg);
	} else {
		nu_write_ecc_key(ctx, curve->Pp, ECC_N);
	}
	return 0;
}

static int nuvoton_ecc_point_mult(struct nu_ecc_ctx *ctx, u8 *private_key,
					u8 *public_key, u8 *result)
{
	struct nu_ecc_dev  *dd = ctx->dd;
	struct tee_ioctl_invoke_arg inv_arg;
	struct tee_param param[4];
	int	err;

	if (public_key != NULL) {
		nu_write_ecc_key(ctx, public_key, ECC_X1);
		nu_write_ecc_key(ctx, public_key + ctx->keylen, ECC_Y1);

	} else {
		/* use G point */
	}

	nu_write_reg(dd, 0, ECC_KSCTL);
	nu_write_reg(dd, 0, ECC_KSXY);

	nu_write_ecc_key(ctx, private_key, ECC_K);

	nu_write_reg(dd, ((ctx->keylen * 8) << ECC_CTL_CURVEM_OFFSET) |
		ECC_CTL_FSEL | ECCOP_POINT_MUL | ECC_CTL_START, ECC_CTL);

	if (dd->nu_cdev->use_optee == false) {
		err = nuvoton_wait_ecc_complete(dd, 2000);
		if (err)
			return err;
	} else {
		/*
		 *  Invoke OP-TEE Crypto PTA to run ECC
		 */
		memset(&inv_arg, 0, sizeof(inv_arg));
		memset(&param, 0, sizeof(param));

		/* Invoke PTA_CMD_CRYPTO_ECC_PMUL function of PTA */
		inv_arg.func = PTA_CMD_CRYPTO_ECC_PMUL;
		inv_arg.session = dd->session_id;
		inv_arg.num_params = 4;

		/* Fill invoke cmd params */
		param[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT;
		param[1].attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT;
		param[2].attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT;

		param[0].u.value.a = ctx->curve->curve_id;
		param[1].u.memref.shm = dd->shm_pool;
		param[1].u.memref.size = CRYPTO_SHM_SIZE;
		param[1].u.memref.shm_offs = 0;
		param[2].u.value.a = 0x1000;
		param[2].u.value.b = 0x2000;

		if (public_key != NULL) {
			ecc_key_to_str(public_key,
				(char *)&dd->va_shm[0x1000 / 4], ctx->keylen);
			ecc_key_to_str(public_key + ctx->keylen,
				(char *)&dd->va_shm[0x1240 / 4], ctx->keylen);
		} else {
			ecc_key_to_str((u8 *)ctx->curve->Px,
				(char *)&dd->va_shm[0x1000 / 4], ctx->keylen);
			ecc_key_to_str((u8 *)ctx->curve->Py,
				(char *)&dd->va_shm[0x1240 / 4], ctx->keylen);
		}
		ecc_key_to_str(private_key,
				(char *)&dd->va_shm[0x1480 / 4], ctx->keylen);

		err = tee_client_invoke_func(dd->octx, &inv_arg, param);
		if ((err < 0) || (inv_arg.ret != 0)) {
			pr_err("PTA_CMD_CRYPTO_ECC_PMUL err: %x\n",
				inv_arg.ret);
			return -EINVAL;
		}
	}
	nu_read_ecc_key(ctx, ECC_X1, result);
	nu_read_ecc_key(ctx, ECC_Y1, result + ctx->keylen);
	return 0;
}

static int nuvoton_ecdh_set_secret(struct crypto_kpp *tfm, const void *buf,
				   unsigned int len)
{
	struct nu_ecc_ctx *ctx = kpp_tfm_ctx(tfm);
	struct nu_ecc_dev *dd = nuvoton_ecc_find_dev(ctx);
	struct ecdh	params;
	unsigned int	ndigits;
	int		err;

	ctx->dd = dd;
	if ((dd->nu_cdev->use_optee) && (dd->octx == NULL)) {
		if (optee_ecc_open(dd) != 0)
			return -ENODEV;
	}

	if (crypto_ecdh_decode_key(buf, len, &params) < 0) {
		pr_err("crypto_ecdh_decode_key failed!\n");
		return -EINVAL;
	}

	if (params.curve_id == ECC_CURVE_NIST_P192) {
		ndigits = 3;
		err = nuvoton_ecc_init_curve(CURVE_P_192, ctx);
	} else if (params.curve_id == ECC_CURVE_NIST_P256) {
		ndigits = 4;
		err = nuvoton_ecc_init_curve(CURVE_P_256, ctx);
	} else {
		pr_err("%s - Invalid curve id!\n", __func__);
		return -EINVAL;
	}
	if (err)
		return err;

	if (!params.key || !params.key_size)
		return ecc_gen_privkey(params.curve_id, ndigits,
					   (u64 *)ctx->private_key);

	if (ecc_is_key_valid(params.curve_id, ndigits,
			     (const u64 *)params.key,
			     params.key_size) < 0) {
		pr_err("[%s] - input key is invalid!\n", __func__);
		return -EINVAL;
	}

	memcpy(ctx->private_key, params.key, params.key_size);
	return 0;
}

static int nuvoton_ecdh_compute_value(struct kpp_request *req)
{
	struct crypto_kpp *tfm = crypto_kpp_reqtfm(req);
	struct nu_ecc_ctx *ctx = kpp_tfm_ctx(tfm);
	struct nu_ecc_dev *dd = ctx->dd;
	u8	public_key[NU_ECC_MAX_LEN * 2];
	u8	shared_secret[NU_ECC_MAX_LEN * 2];
	void	*buf;
	int	copied, nbytes, public_key_sz;
	int	ret;

	if ((dd->nu_cdev->use_optee) && (dd->octx == NULL)) {
		if (optee_ecc_open(dd) != 0)
			return -ENODEV;
	}

	ctx->dd = dd;
	ret = nuvoton_ecc_init_curve(ctx->curve_id, ctx);
	if (ret)
		return ret;
	nbytes = ctx->keylen;
	/* Public part is a point thus it has both coordinates */
	public_key_sz = 2 * nbytes;

	if (req->src) {
		/* must have exactly two points to be on the curve */
		if (public_key_sz != req->src_len)
			return -EINVAL;

		copied = sg_copy_to_buffer(req->src,
					   sg_nents_for_len(req->src,
								public_key_sz),
					   public_key, public_key_sz);
		if (copied != public_key_sz)
			return -EINVAL;

		ret = nuvoton_ecc_point_mult(ctx, ctx->private_key,
						public_key, shared_secret);

		buf = shared_secret;
	} else {
		/* Make public key by private key and G */
		ret = nuvoton_ecc_point_mult(ctx, ctx->private_key,
						NULL, public_key);
		buf = public_key;
		nbytes = public_key_sz;
	}

	if (ret < 0)
		return ret;

	/* might want less than we've got */
	nbytes = min_t(size_t, nbytes, req->dst_len);
	copied = sg_copy_from_buffer(req->dst,
				sg_nents_for_len(req->dst, nbytes),
				buf, nbytes);
	if (copied != nbytes)
		ret = -EINVAL;

	return ret;
}

static unsigned int nuvoton_ecdh_max_size(struct crypto_kpp *tfm)
{
	struct nu_ecc_ctx *ctx = kpp_tfm_ctx(tfm);

	/* Public key is made of two coordinates, add one to the left shift */
	return (ctx->keylen * 2);
}

static struct kpp_alg nuvoton_ecdh = {
	.set_secret = nuvoton_ecdh_set_secret,
	.generate_public_key = nuvoton_ecdh_compute_value,
	.compute_shared_secret = nuvoton_ecdh_compute_value,
	.max_size = nuvoton_ecdh_max_size,
	.base = {
		.cra_flags = CRYPTO_ALG_NEED_FALLBACK,
		.cra_name = "ecdh",
		.cra_driver_name = "nuvoton-ecdh",
		.cra_priority = 400,
		.cra_module = THIS_MODULE,
		.cra_ctxsize = sizeof(struct nu_ecc_ctx),
	},
};

static int  optee_ecc_open(struct nu_ecc_dev *dd)
{
	struct tee_ioctl_open_session_arg sess_arg;
	int   err;

	err = nuvoton_crypto_optee_init(dd->nu_cdev);
	if (err)
		return err;
	/*
	 * Open ECC context with TEE driver
	 */
	dd->octx = tee_client_open_context(NULL, optee_ctx_match,
						   NULL, NULL);
	if (IS_ERR(dd->octx)) {
		pr_err("%s open context failed, err: %x\n", __func__,
			sess_arg.ret);
		return err;
	}

	/*
	 * Open ECC session with Crypto Trusted App
	 */
	memset(&sess_arg, 0, sizeof(sess_arg));
	memcpy(sess_arg.uuid, dd->nu_cdev->tee_cdev->id.uuid.b, TEE_IOCTL_UUID_LEN);
	sess_arg.clnt_login = TEE_IOCTL_LOGIN_PUBLIC;
	sess_arg.num_params = 0;

	err = tee_client_open_session(dd->octx, &sess_arg, NULL);
	if ((err < 0) || (sess_arg.ret != 0)) {
		pr_err("%s open session failed, err: %x\n", __func__,
			sess_arg.ret);
		err = -EINVAL;
		goto out_ctx;
	}
	dd->session_id = sess_arg.session;

	/*
	 * Allocate handshake buffer from OP-TEE share memory
	 */
	dd->shm_pool = tee_shm_alloc(dd->octx, CRYPTO_SHM_SIZE,
				TEE_SHM_MAPPED | TEE_SHM_DMA_BUF);
	if (IS_ERR(dd->shm_pool)) {
		pr_err("%s tee_shm_alloc failed\n", __func__);
		goto out_sess;
	}

	dd->va_shm = tee_shm_get_va(dd->shm_pool, 0);
	if (IS_ERR(dd->va_shm)) {
		tee_shm_free(dd->shm_pool);
		pr_err("%s tee_shm_get_va failed\n", __func__);
		goto out_sess;
	}
	return 0;

out_sess:
	tee_client_close_session(dd->octx, dd->session_id);
out_ctx:
	tee_client_close_context(dd->octx);
	return err;
}

static void optee_ecc_close(struct nu_ecc_dev *dd)
{
	tee_shm_free(dd->shm_pool);
	tee_client_close_session(dd->octx, dd->session_id);
	tee_client_close_context(dd->octx);
	dd->octx = NULL;
}

static long nvt_ecc_ioctl(struct file *filp, unsigned int cmd,
			  unsigned long arg)
{
	struct nu_ecc_dev  *dd;
	struct nu_ecc_ctx  *ecc_ctx = filp->private_data;
	u8	kbuf[160];
	u32	ecc_ctl;
	int	use_optee;
	int	ret;
	struct tee_ioctl_invoke_arg inv_arg;
	struct tee_param param[4];

	if (!ecc_ctx)
		return -EINVAL;

	if (cmd != ECC_IOC_SET_CURVE) {
		if ((ecc_ctx->keylen > 72) || (ecc_ctx->keylen < 20)) {
			pr_err("%s - invalid key length: %d\n",
				__func__, ecc_ctx->keylen);
			return -EINVAL;
		}
	}
	dd = ecc_ctx->dd;
	use_optee =  dd->nu_cdev->use_optee;

	switch (cmd) {
	case ECC_IOC_SET_CURVE:
		if (use_optee)
			memset(dd->va_shm, 0, CRYPTO_SHM_SIZE);
		return nuvoton_ecc_init_curve(arg, ecc_ctx);

	case ECC_IOC_SET_PRIV_KEY:
		if (copy_from_user(kbuf, (u8 *)arg, ecc_ctx->keylen))
			return -EFAULT;

		if (use_optee) {
			ecc_key_to_str(kbuf, (char *)&dd->va_shm[0x1480 / 4],
					ecc_ctx->keylen);
		} else {
			nu_write_ecc_key(ecc_ctx, kbuf, ECC_K);
		}
		break;

	case ECC_IOC_SET_PUB_KEY:
		if (arg == 0) {
			/* use G point, G should have been set on init */
			/* Do nothing. */
			if (use_optee) {
				ecc_key_to_str((u8 *)ecc_ctx->curve->Px,
					(char *)&dd->va_shm[0x1000 / 4], ecc_ctx->keylen);
				ecc_key_to_str((u8 *)ecc_ctx->curve->Py,
					(char *)&dd->va_shm[0x1240 / 4], ecc_ctx->keylen);
			}
		} else {
			if (copy_from_user(kbuf, (u8 *)arg, ecc_ctx->keylen * 2))
				return -EFAULT;
			if (use_optee) {
				ecc_key_to_str(kbuf,
					(char *)&dd->va_shm[0x1000 / 4], ecc_ctx->keylen);
				ecc_key_to_str(kbuf + ecc_ctx->keylen,
					(char *)&dd->va_shm[0x1240 / 4], ecc_ctx->keylen);
			} else {
				nu_write_ecc_key(ecc_ctx, kbuf, ECC_X1);
				nu_write_ecc_key(ecc_ctx, &kbuf[ecc_ctx->keylen], ECC_Y1);
			}
		}
		break;

	case ECC_IOC_POINT_MUL:
		nu_write_reg(dd, 0, ECC_KSCTL);
		nu_write_reg(dd, 0, ECC_KSXY);
		if (ecc_ctx->curve->GF == (int)CURVE_GF_2M) {
			ecc_ctl = 0x0;
		} else {
			/*  CURVE_GF_P */
			ecc_ctl = ECC_CTL_FSEL;
		}
		nu_write_reg(dd, (ecc_ctx->curve->key_len <<
			     ECC_CTL_CURVEM_OFFSET) | ECCOP_POINT_MUL |
			     ECC_CTL_START | ecc_ctl, ECC_CTL);

		if (use_optee == false) {
			ret = nuvoton_wait_ecc_complete(dd, 2000);
			if (ret)
				return ret;
		} else {
			/*
			 *  Invoke OP-TEE Crypto PTA to run ECC
			 */
			memset(&inv_arg, 0, sizeof(inv_arg));
			memset(&param, 0, sizeof(param));

			/* Invoke PTA_CMD_CRYPTO_ECC_PMUL function of PTA */
			inv_arg.func = PTA_CMD_CRYPTO_ECC_PMUL;
			inv_arg.session = dd->session_id;
			inv_arg.num_params = 4;

			/* Fill invoke cmd params */
			param[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT;
			param[1].attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT;
			param[2].attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT;

			param[0].u.value.a = ecc_ctx->curve->curve_id;
			param[1].u.memref.shm = dd->shm_pool;
			param[1].u.memref.size = CRYPTO_SHM_SIZE;
			param[1].u.memref.shm_offs = 0;
			param[2].u.value.a = 0x1000;
			param[2].u.value.b = 0x2000;

			ret = tee_client_invoke_func(dd->octx, &inv_arg, param);
			if ((ret < 0) || (inv_arg.ret != 0)) {
				pr_err("PTA_CMD_CRYPTO_ECC_PMUL err: %x\n",
					inv_arg.ret);
				return -EINVAL;
			}
		}
		nu_read_ecc_key(ecc_ctx, ECC_X1, kbuf);
		nu_read_ecc_key(ecc_ctx, ECC_Y1, &kbuf[ecc_ctx->keylen]);
		if (copy_to_user((char *)arg, kbuf, ecc_ctx->keylen * 2))
			return -EFAULT;
		break;

	default:
		return -ENOTTY;
	}
	return 0;
}

static int nvt_ecc_open(struct inode *inode, struct file *file)
{
	struct nu_ecc_ctx  *ecc_ctx;

	ecc_ctx = kzalloc(sizeof(*ecc_ctx), GFP_KERNEL);
	if (!ecc_ctx)
		return -ENOMEM;
	ecc_ctx->dd = __ecc_dd;
	file->private_data = ecc_ctx;

	if ((__ecc_dd->nu_cdev->use_optee) && (__ecc_dd->octx == NULL)) {
		if (optee_ecc_open(__ecc_dd) != 0)
			return -ENODEV;
	}
	return 0;
}

static int nvt_ecc_close(struct inode *inode, struct file *file)
{
	struct nu_ecc_ctx  *ecc_ctx;

	ecc_ctx = file->private_data;
	if (!ecc_ctx)
		return -EIO;
	kfree(ecc_ctx);
	return 0;
}

const struct file_operations nvt_ecc_fops = {
	.owner		= THIS_MODULE,
	.unlocked_ioctl	= nvt_ecc_ioctl,
	.open           = nvt_ecc_open,
	.release        = nvt_ecc_close,
};

static struct miscdevice nvt_ecc_dev = {
	.minor		= MISC_DYNAMIC_MINOR,
	.name		= "nuvoton-ecc",
	.fops		= &nvt_ecc_fops,
};

int nuvoton_ecc_probe(struct device *dev,
			  struct nu_crypto_dev *nu_cryp_dev)
{
	struct nu_ecc_dev  *ecc_dd = &nu_cryp_dev->ecc_dd;
	int   err = 0;

	__ecc_dd = ecc_dd;
	ecc_dd->dev = dev;
	ecc_dd->nu_cdev = nu_cryp_dev;
	ecc_dd->reg_base = nu_cryp_dev->reg_base;
	ecc_dd->octx = NULL;

	INIT_LIST_HEAD(&ecc_dd->list);
	spin_lock_init(&ecc_dd->lock);

	spin_lock(&nu_ecc.lock);
	list_add_tail(&ecc_dd->list, &nu_ecc.dev_list);
	spin_unlock(&nu_ecc.lock);

	if (nu_cryp_dev->ecc_ioctl == true) {
		misc_register(&nvt_ecc_dev);
	} else {
		err = crypto_register_kpp(&nuvoton_ecdh);
		if (err) {
			dev_err(dev, "register ecdh failed\n");
			goto err_out;
		}
	}

	pr_info("MA35D1 Crypto ECC engine enabled.\n");
	return 0;

err_out:
	spin_lock(&nu_ecc.lock);
	list_del(&ecc_dd->list);
	spin_unlock(&nu_ecc.lock);

	dev_err(dev, "MA35D1 ECC initialization failed. %d\n", err);
	return err;
}

int nuvoton_ecc_remove(struct device *dev,
			   struct nu_crypto_dev *nu_cryp_dev)
{
	struct nu_ecc_dev  *ecc_dd = &nu_cryp_dev->ecc_dd;

	if (ecc_dd == NULL)
		return -ENODEV;

	if (nu_cryp_dev->ecc_ioctl == true)
		misc_deregister(&nvt_ecc_dev);
	else
		crypto_unregister_kpp(&nuvoton_ecdh);

	spin_lock(&nu_ecc.lock);
	list_del(&ecc_dd->list);
	spin_unlock(&nu_ecc.lock);

	if (nu_cryp_dev->use_optee)
		optee_ecc_close(ecc_dd);
	return 0;
}


